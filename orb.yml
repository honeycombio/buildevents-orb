version: 2.1

description: |
  Install and use the Honeycomb buildevents tool for generating traces of your builds

  Please see the Buildevents Orb Readme (https://github.com/honeycombio/buildevents-orb)
  for use instructions

commands:
  start_trace:
    description: |
      start_trace should be run in a job all on its own at the very beginning of
      a build. This job initializes the buildevents config, downloads the
      buildevents binary, and otherwise gets the build environment ready for the
      rest of the jobs.
    steps:
      ### set up buildevents
      - run:
          name: setup honeycomb buildevents and start trace
          command: |
            # set up our working environment and timestamp the trace
            mkdir -p /tmp/be/bin-linux /tmp/be/bin-darwin
            date +%s > /tmp/be/build_start

            # get all buildevenst binaries so jobs in any OS will work
            curl -q -L -o /tmp/be/bin-linux/buildevents https://github.com/honeycombio/buildevents/releases/download/v0.4.4/buildevents-linux-amd64
            curl -q -L -o /tmp/be/bin-darwin/buildevents https://github.com/honeycombio/buildevents/releases/download/v0.4.4/buildevents-darwin-amd64

            # make them executable
            chmod 755 /tmp/be/bin-linux/buildevents
            chmod 755 /tmp/be/bin-darwin/buildevents
      - persist_to_workspace:
          root: /tmp
          paths:
            - be/build_start
            - be/bin-linux/buildevents
            - be/bin-darwin/buildevents
      - run:
          name: report_step
          command: |
            # choose the right buildevents binary
            if uname -a | grep Linux | grep x86_64 > /dev/null 2>&1 ; then
              export PATH=$PATH:/tmp/be/bin-linux
            elif uname -a | grep Darwin > /dev/null 2>&1; then
              export PATH=$PATH:/tmp/be/bin-darwin
            fi
            # use that binary to report this step
            buildevents step $CIRCLE_WORKFLOW_ID setup $(cat /tmp/be/build_start) start_trace

  watch_build_and_finish:
    description: |
      watch_build_and_finish will poll the CircleCI API to determine when the
      build is done. It should be its own job dependent on the job that runs
      start_trace, and no job should depend on it finishing.
    parameters:
      timeout:
        description: Timeout after which we consider the build failed, in minutes. Should be at least double your longest expected build.
        type: integer
        default: 20
    steps:
      - attach_workspace:
          at: /tmp/buildevents
      - run:
          name: watch then finish build trace
          command: |
            # choose the right buildevents binary
            if uname -a | grep Linux | grep x86_64 > /dev/null 2>&1 ; then
              export PATH=$PATH:/tmp/buildevents/be/bin-linux:/tmp/be/bin-linux
            elif uname -a | grep Darwin > /dev/null 2>&1; then
              export PATH=$PATH:/tmp/buildevents/be/bin-darwin:/tmp/be/bin-darwin
            fi
            # set the timeout
            export BUILDEVENT_TIMEOUT=<< parameters.timeout >>
            buildevents watch $CIRCLE_WORKFLOW_ID

  finish:
    description: |
      finish is an alternative to watch_build_and_finish. If you can't create a
      CircleCI API token or want to manually finish the trace, you can use this
      command to do so. If you can, it's recommended that you use
      watch_build_and_finish instead of this command.
    parameters:
      result:
        description: The final status of the build. Should be either "success" or "failure".
        type: string
    steps:
      - attach_workspace:
          at: /tmp/buildevents
      - run:
          name: Finish the build by sending the root span
          command: |
            # choose the right buildevents binary
            if uname -a | grep Linux | grep x86_64 > /dev/null 2>&1 ; then
              export PATH=$PATH:/tmp/buildevents/be/bin-linux:/tmp/be/bin-linux
            elif uname -a | grep Darwin > /dev/null 2>&1; then
              export PATH=$PATH:/tmp/buildevents/be/bin-darwin:/tmp/be/bin-darwin
            fi
            buildevents build $CIRCLE_WORKFLOW_ID $(cat /tmp/buildevents/be/build_start) << parameters.result >>

  with_job_span:
    parameters:
      steps:
        type: steps
    steps:
      - attach_workspace:
          at: /tmp/buildevents
      - run:
          name: starting span for job
          command: |
            mkdir -p /tmp/buildevents/be/${CIRCLE_JOB}
            date +%s > /tmp/buildevents/be/${CIRCLE_JOB}/start
            BUILDEVENTS_SPAN_ID=$(echo $CIRCLE_JOB | sha256sum | awk '{print $1}')
            echo $BUILDEVENTS_SPAN_ID > /tmp/buildevents/be/${CIRCLE_JOB}/span_id

            # in case this is a bash env, be kind and export the buildevents path and span ID
            # this orb won't rely on them but consumers of the orb might find it useful
            # this way steps that are run within a span can use the raw buildevents if desired
            echo "export BUILDEVENTS_SPAN_ID=$BUILDEVENTS_SPAN_ID" >> $BASH_ENV
            if uname -a | grep Linux | grep x86_64 > /dev/null 2>&1 ; then
              echo "export PATH=$PATH:/tmp/buildevents/be/bin-linux:/tmp/be/bin-linux" >> $BASH_ENV
            elif uname -a | grep Darwin > /dev/null 2>&1; then
              echo "export PATH=$PATH:/tmp/buildevents/be/bin-darwin:/tmp/be/bin-darwin" >> $BASH_ENV
            fi

      ### run the job's steps
      - steps: << parameters.steps >>

      - run:
          name: finishing span for job
          command: |
            # choose the right buildevents binary
            if uname -a | grep Linux | grep x86_64 > /dev/null 2>&1 ; then
              export PATH=$PATH:/tmp/buildevents/be/bin-linux:/tmp/be/bin-linux
            elif uname -a | grep Darwin > /dev/null 2>&1; then
              export PATH=$PATH:/tmp/buildevents/be/bin-darwin:/tmp/be/bin-darwin
            fi

            # if there are any extra context values, add them
            if [ -e /tmp/buildevents/extra_fields.lgfmt ] ; then
              export BUILDEVENT_FILE=/tmp/buildevents/extra_fields.lgfmt
            fi

            # go ahead and report the span
            buildevents step $CIRCLE_WORKFLOW_ID \
              $(cat /tmp/buildevents/be/${CIRCLE_JOB}/span_id) \
              $(cat /tmp/buildevents/be/${CIRCLE_JOB}/start) \
              $CIRCLE_JOB
          when: always

  add_context:
    description: |
      add_context is a function to add additional fields to the span
      representing this job. It can be called multiple times, each with one
      value. It is useful for adding things like artifact sizes, parameters to
      the job, and so on. Call this with two arguments - the field name and the
      field value. Both name and value must be strings, but numbers will be
      coerced before getting sent to Honeycomb. Names must be single words;
      values can be longer strings. This must be used within the context of
      `with_job_span`
    parameters:
      field_name:
        description: the name of the field to add to the surrounding step
        type: string
      field_value:
        description: the value of the field to add to the surrounding step
        type: string
      verbose:
        description: |
          if set to `true`, the extra context field name and content will be
          evaluated and echoed to your build log in addition to being sent to
          Hoenycomb
        type: boolean
        default: false
    steps:
      - run: |
          if [ "<< parameters.verbose >>" == "true" ] ; then
            echo "adding the following context to the trace:"
            echo field: << parameters.field_name >>
            echo value: << parameters.field_value >>
          fi
          echo << parameters.field_name >>=\"<< parameters.field_value >>\" >> /tmp/buildevents/extra_fields.lgfmt

  berun:
    description: |
      berun executes a command and creates a span representing that command. The
      bename parameter will be the name of the span. berun must be used within a
      step decorated by with_job_span.
    parameters:
      bename:
        type: string
      becommand:
        type: string
    steps:
      - run:
          name: << parameters.bename >>
          command: |
            # choose the right buildevents binary
            if uname -a | grep Linux | grep x86_64 > /dev/null 2>&1 ; then
              export PATH=$PATH:/tmp/buildevents/be/bin-linux:/tmp/be/bin-linux
            elif uname -a | grep Darwin > /dev/null 2>&1; then
              export PATH=$PATH:/tmp/buildevents/be/bin-darwin:/tmp/be/bin-darwin
            fi
            buildevents cmd $CIRCLE_WORKFLOW_ID \
              $(cat /tmp/buildevents/be/${CIRCLE_JOB}/span_id) \
              << parameters.bename >> -- << parameters.becommand >>
